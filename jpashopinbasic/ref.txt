h2 database 관련

jpa shop = > test

exhellojpa=> test2
=====================================================

JPA 동작 방식

Persistence 가 META-INF 아래에 있는 persistence.xml의 설정을 읽어들여서
EntityManagerFactory를 생성하고, 필요할 때마다 이 factory에서 EntityManager를 꺼내다 사용한다.


cf) EntityManager : Java의 collection 처럼, 내가 저장하고 싶은 데이터를 대신 저장해준다고 생각하기 (persist, find, ...)

EntityManagerFactory는 하나만 생성해서 에플리케이션 전체에 공유
EntityManager는 쓰레드간에 공유하면 안된다 (한번 사용하고 버리기.)
JPA에서 데이터를 변경하는 모든 작업은 트랜잭션 안에서 실행되어야 한다!


cf ) JPQL  VS SQL

JPQL = Entity 객체를 대상으로 query. -> queryDialect를 이용하여 현재 database 종류에 맞는 적절한 query문이 생성됨!
SQL = Database table을 대상으로 query.

==========================================================

[영속성 컨텍스트] : "Entity를 영구적으로 저장하는 환경"

EntityManager를 통해서 눈에 보이지 않는 영속성 컨텍스트에 접근한다 ? 의 느낌?

server up 시 EntityManagerFactory가 생성되고
client의 요청이 있을 때마다 이 factory에서 EntityManager를 꺼내다 쓴다고 생각.
EntityManager는 내부적으로 DB의 Connection Pool로부터 connection 객체를 이용하여 db에 접근한다.

persist()와 같이 영속성 컨텍스트 안에 들어간다고 해서 바로 쿼리가 실행되는 것이 아님.
트랜잭션이 커밋되는 시점에 쿼리가 생성되어 db에 반영됨.
업데이트의 경우 커밋 직전에 영속성 컨텍스트에서 관리하는 Entity에 변경사항이 있는지 감지(dirty checking) 후
변경사항이 있으면 업데이트 쿼리를 날린 후에 commit 실행!


cf) detach() => 영속성 context에서 지우는 함수

em.persist(member) member 객체를 영속성 context에 포함시킴, 이때부터 이미 pk가 생성됨(영속성 context로서 관리하려면 pk가 무조건 있어야 하믈)
em.detach(member) member 객체를 영속성 context 관리 대상에서 제외시킴

영속성 컨텍스트의 이점
 - application과 database 사이에 중간 계층이 있는 느낌..?
 1. 변경 감지( Dirty checking)
    - tx.commit(); 시 flush(); 호출. -> 현재 entity 상태와 snapshot(snapshot: db에서 값을 읽어온 최초 시점에 저장해둔 상태값) 비교 -> 다른 부분 있으면 update sql 생성 -> flush 및 commit
    -> jpa는 값을 바꾸면 트랜잭션이 commit 되는 시점에 변경을 반영하는구나~ em.persist를 따로 하지 않고 setter로 해주면 되는군.
    -  참고) flush란? : 영속성 컨텍스트의 변경내용을 db에 반영하는 것 (db에 commit될 때 flush가 호출됨) (영속성 컨텍스트를 비우는 것이 아님.착각X)
                     : 영속성 컨텍스트를 flush 하는 세가지 방법
                        1) em.flush() 직접 호출 // 잘 안씀.
                        2) 트랜잭션 커밋 (플러시 자동 호출)
                        3) JPQL 쿼리 실행 (플러시 자동 호출)
 2. 지연 로딩( Lazy loading)
 3. 1차 캐시 (primary caching) (동일한 트랜잭션 안에서만 1차 캐시 존재. 따라서 성능상에 큰 이점이 있지는 않음 . )

===========================================================================================================================================
트랜잭션 : 수행되어아 할 일련의 연산들 ...
JPA는 영속성 컨텍스트에 지연 로딩 SQL 문을 저장해놓는데. 이 SQL문은 영속성 컨텍스트에서 관리하는 Entity에 변경 사항을 주는 쿼리문들이다.
이 쿼리문들은 하나의 트랜잭션으로 처리되고 트랜잭션이 커밋될 때 db에 한꺼번에 반영된다 (?)

=============================================================================

[준영속 상태]

우선 em.find()로 가져온 것/ em.persist() 한 것 두가지는 기본적으로 영속 상태
영속성 컨텍스트에서 더이상 관리하지 않겠다 (jpa에서 더이상 관리 x )=> 준영속 상태로 전환

em.detach(특정객체이름); => 특정 객체만 준영속 상태로 만들겠다
em.clear(); => EntityManager 안에 있는 영속성 컨텍스트를 통채로 다 지워버림
em.close(); => 영속성 컨텍스트를 종료

=================================================================================

양방향 연관관계

- 연관관계의 주인 : 외래키가 있는 테이블을 주인으로 정하기 . (1:n 관계일때 n쪽!)
                주인이 아닌 쪽은 (mappedby="주인에서 참조하는 변수명")으로 양방향 연관관계 매핑.
cf) 설계 시 단방향 매핑을 먼저 하면 이미 연관관계 매핑은 완료된 것.
양방향 매핑은 반대 방향으로 조회하는 기능이 추가된 것 (실무에서 역방향 탐색이 많이 이용됨)
단방향 매핑을 먼ㄴ저 해두고, 양방향은 필요할 때 추가하는 방식으로 사용해도 ok.
예시)
(team:member=1:n이니까 , member class에만 Team team 을 추가해놓고 (단방향 1st)
이후에 필요할 때에 e.g)하나의 팀의 모든 member를 조회하고 싶을 때(역방향 탐색) Team class 에 List<Member>를 추가하는 방식!

테이블은 외래 키 하나로 두 테이블이 연관관게를 맺고, 두 테이블을 모두 조회할 수 있음
객체 양방향 관계는 a->b, b->a처럼 참조가 두군데이기 때문에 둘 중 테이블의 외래 키를 관리할 곳 (연관관계의 주인)을 지정해야 함!
연관관계 주인의 반대편은 단순 조회만 가능하다
연관관계 주인에서 값이 변경되면 종속된 곳도 같이 변한다 (확실하지 않고, 확인해봐야함!)


연관관계 편의 메서드
- 1쪽이든 N쪽이든 한 군데에만 두면 된다.
- 1인지 N인지는 상황마다 다르니 판단 후 사용.
cf) entity 는 controller에서 직접 반환하면 안됨. 꼭 dto 사용할 것!

===============================================================================================

연관관계


x대y 에서 x가 연관관계의 주인 인 경우를 상정하고 쓴 것임.

1. 다대일

다 테이블 쪽에 외래키 있음 (관계형 db에서는 다 쪽에 항상 외래키가 있음)
참고로 외래키가 있는 곳이 연관관계의 주인임.

2. 일대다
일대다 단방향 매핑보다는 다대일 양방향 매핑 사용을 권장

3. 일대일
주 테이블이나 대상 테이블 둘 중 외래키 선택 가능 ,
참조 : select 많이 하는 테이블의 경우 fk가 있으면 좋음. (일대일 관계에서 )
나중에 일대 다로 변할 가능성이 있는 관계의 경우 다 쪽에 외래키!

4. 다대다
실무에서 절대 쓰면 안됨
관계형 db에서는 무조건 다대다를 일대 다, 다대일 관계로 풀어내야함.

JPA main start 시켜서 쿼리문 나오는거 볼 수 있음!

===================================================================================================

상속관계 매핑

1. 조인 전략
    장점 : 테이블 정규화 .
    단점 : 조회시 JOIN을 많이 사용하기 때문에 성능 저하 가능성. 데이터 저장시 INSERT 두번 호출.

2. 단일 테이블 전략
    장점 : 일반적으로 조회 성능이 빠름.
    단점 : 자식 엔티티 컬럼은 모두 NULL 허용 해줘야함.

3. 각각 테이블 전략 : 구현 클래스마다 테이블 전략 ( 웬만하면 쓰면 안되는 방식)ㅛㅗㅕㅓㅑㅏㅣㅗㅛ

    장점 :
    단점 :

    보통 DEFAULT로 조인 전략을 하면 좋지만 . 아주 단순한 경우에는 단일 테이블 !
    비즈니스적으로 중요하고 복잡한 경우 조인 전략을 사용한다고 함. 고민해봐야함.

========================================================================================================
JPA 엔티티

기본값 타입 - int, double, Integer, Long, String
임베디드 타입 - 예) 좌표 (x,y)를 하나의 값으로 사용하고 싶을 때 Position이라는 class를 만들고, 이 Position이 임베디드 타입이 된다.
    - 새로운 값 타입을 개발자가 직접 정의할 수 있음
    - 기본 값 타입을 모아서 만드는 경우가 많음.
    - 기본 생성자 필수 !

    - 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유했을 경유, 하나의 값만 바꿔도 모든 엔티티에서 그 임베티드 타입 값이 바뀔 수 있음 (위험)
    -  예) Address =>  Embedded Type, member 1, member2 의 address 가 같은 객체로 값이 들어갔다고 가정.
    만약 member1의 address만 바꾸려고 setAddress()를 한 경우 member2의 address 도 바뀌는 결과 초래 .
    => 이런 경우에는 Address를 Embedded Type이 아닌 BaseEntity로 설정해야 함. 또는 다른 객체로 복사해서 값을 넣어주면 ok.
   -> 임베디드 타입의 setter를 막거나 private setter를 생성해 외부에서 수정할 수 없게 불변 객체로 설정하는 것도 하나의 방법.

   값 타입은 무조건 불변 객체로 만드는 것이 현명 .

컬렉션 값 타입 - 자바 Collection.에 기본값 타입이나 임베디드 타입을 넣는 것

===============================================================================================================

JPQL - Entity 객체 대상으로 쿼리 날림. 객체 지향 sql, 특정 db sql에 의존하지 않음.
JPQL을 짜면 결국 SQL문으로 번역되어서 DB에 쿼리문이 나감.
    cf) 실무에서 criteria 안씀.
    criteria 대신에 queryDSL 제공함 (라이브러리임) / 실무에서 queryDSL 사용함!


QueryDSL
    - 오픈 소스 library (www.querydsl.com)
    - JPQL을 개발자가 직접 작성하는게 아닌 자바 코드로 JPQL을 작성할 수 있음
    - JPQL Builder 느낌이라 보면 될 듯.
    - 컴파일 시점에 오류를 찾을 수 있음 (IDE 빨갛게 뜨는 거 ..)
    - 단순하고 쉬움. 실무 사용 권장
    - 동적 쿼리 작성 편리!! (mybatis의 장점을 가져온 듯..)

NativeSQL
    - 특정 db에 종속적인 기능 (oracle의 connect by.. 같은거 사용할 때 필요 )
    - em.createNativeQuery("생쿼리");


or
    JDBC Template , Mybatis를 조합해서 함꼐 사용 할 수 있음.
    ( 단 영속성 컨텍스트가 flush 되어야 db에 반영이 되기 때문에, 이 두개를 사용한다면
    적절한 시점에 강제로 flush 호출해야한다. em.flush();

    em.flush() : 영속성 context를 비우면서 db에 반영하는 과정.
    em.flush() 는 em.commit()를 호출하거나 em.createNativeQuery() 할 때 자동으로 호출된다!

